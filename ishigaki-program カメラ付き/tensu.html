<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <title>å®¶ç´‹åˆ†é¡ã‚µã‚¤ãƒˆï¼ˆTeachable Machine + OpenCV.jsï¼‰</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    canvas {
      margin-top: 0.5rem;
      max-width: 60vw;   /* ç”»é¢å¹…ã® 60% ã¾ã§ã€‚ã‚‚ã£ã¨å°ã•ãã—ãŸã‘ã‚Œã° 40vw ãªã©ã« */
      height: auto;      /* ç¸¦æ¨ªæ¯”ã‚’ä¿ã£ãŸã¾ã¾ç¸®å° */
      border: 1px solid #444;
    }
  </style>
  
</head>

<body>
    <h1>çŸ³å£è¨ºæ–­è£œåŠ©ã‚µã‚¤ãƒˆ</h1>
    <nav class="nav">
            <ul>
                <li><a href="index.html">ãƒ›ãƒ¼ãƒ ã¸</a></li>
                <li><a href="koubai.html">å‹¾é…èª¿æŸ»</a></li>
                <li><a href="takasa.html">é«˜ã•èª¿æŸ»</a></li>
                <li><a href="tensu.html">å®¶ç´‹è¨ºæ–­</a></li>
                
            </ul>
            </nav>
  <h2>å®¶ç´‹åˆ†é¡ã‚µã‚¤ãƒˆ</h2>
  <p>ç”»åƒã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã™ã‚‹ã¨ã€AIãŒ <b>ä¸¸ãƒ»å››è§’ãƒ»ä¸‰è§’ãƒ»ãªã—</b> ã®ã„ãšã‚Œã‹ã‚’åˆ¤å®šã—ã¾ã™ã€‚</p>

  <p id="status">â³ ãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿ä¸­...</p>
  <input type="file" id="file" accept="image/*">
  <canvas id="canvas"
  ></canvas>
  <div class="result" id="result"></div>

 <!-- TensorFlow.js -->
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.21.0/dist/tf.min.js"></script>

<!-- Teachable Machine -->
<script src="https://cdn.jsdelivr.net/npm/@teachablemachine/image@0.8/dist/teachablemachine-image.min.js"></script>

<!-- OpenCV.jsï¼ˆå®‰å®šCDNï¼‹ç¢ºèªä»˜ãï¼‰ -->
<script async 
  src="https://docs.opencv.org/4.x/opencv.js"
  onload="document.getElementById('status').textContent += ' âœ… OpenCV.jsèª­ã¿è¾¼ã¿æˆåŠŸ';"
  onerror="alert('âš ï¸ OpenCV.jsã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ã‚‚ã†ä¸€åº¦å†èª­ã¿è¾¼ã¿ã—ã¦ãã ã•ã„ã€‚');">
</script>


  <script>
    const MODEL_URL = "https://teachablemachine.withgoogle.com/models/JssL1cK-Y/";  // â† ã‚ãªãŸã®ãƒ¢ãƒ‡ãƒ«URLã«ç½®ãæ›ãˆ
    let tmModel;

    const statusEl = document.getElementById('status');
    const fileInput = document.getElementById('file');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const resultEl = document.getElementById('result');

    // ---- ãƒ¢ãƒ‡ãƒ«ã‚’èª­ã¿è¾¼ã‚€ ----
    async function loadModel() {
      try {
        const modelURL = MODEL_URL + "model.json";
        const metadataURL = MODEL_URL + "metadata.json";
        tmModel = await tmImage.load(modelURL, metadataURL);
        statusEl.textContent = "âœ… ãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿å®Œäº†ï¼ç”»åƒã‚’é¸ã‚“ã§ãã ã•ã„ã€‚";
      } catch (err) {
        console.error(err);
        statusEl.textContent = "âŒ ãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿å¤±æ•—ï¼šURLã‚„ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚";
      }
    }

    loadModel();

    // ---- ãƒ•ã‚¡ã‚¤ãƒ«é¸æŠæ™‚ ----
    fileInput.addEventListener("change", async (e) => {
      const file = e.target.files[0];
      if (!file || !tmModel) return;

      const img = new Image();
      img.onload = async () => {
        // Canvasã«æç”»
        canvas.width = img.width;
        canvas.height = img.height;
        ctx.drawImage(img, 0, 0);

        // TMãƒ¢ãƒ‡ãƒ«ã§æ¨è«–
        const prediction = await tmModel.predict(img);
        prediction.sort((a, b) => b.probability - a.probability);
        const top = prediction[0];

        resultEl.innerHTML = `ğŸ” çµæœï¼š<b>${top.className}</b>ï¼ˆç¢ºç‡ ${(top.probability*100).toFixed(1)}%ï¼‰`;

// OpenCVã§å›²ã¿ã‚’æç”»ï¼ˆç‰©ä½“ã”ã¨ã«TMã§åˆ†é¡ã—ã¦ãƒãƒ¼ã‚¯ï¼‰ 
if (typeof cv !== 'undefined') {
  const src = cv.imread(canvas);

  // å‰å‡¦ç†
  const gray = new cv.Mat();
  cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY, 0);
  cv.threshold(gray, gray, 0, 255, cv.THRESH_BINARY_INV + cv.THRESH_OTSU);

  // ãƒã‚¤ã‚ºé™¤å»
  const kernel = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(3, 3));
  cv.morphologyEx(gray, gray, cv.MORPH_OPEN, kernel);
  kernel.delete();

  // è¼ªéƒ­æŠ½å‡º
  const contours = new cv.MatVector();
  const hierarchy = new cv.Mat();
  cv.findContours(gray, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

  const W = src.cols, H = src.rows;
  const MIN_AREA = 400;       // å°ã•ã™ãã‚‹ã‚´ãƒŸé™¤å¤–
  const MAX_FRAC = 0.90;      // ç”»åƒé¢ç©ã®90%è¶…ã¯å¤–æ ã¨ã¿ãªã™
  const EDGE_MGN = 2;         // ç«¯æ¥è§¦ã‚’å¤–æ ã¨ã¿ãªã™
  const PAD = 4;              // åˆ‡ã‚Šå‡ºã—æ™‚ã®ä½™ç™½
  const THRESH = 0.80;        // ãã®ç‰©ä½“ã‚’ã€Œå›³å½¢ã‚ã‚Šã€ã¨ã¿ãªã™ç¢ºç‡ã—ãã„å€¤

  // ã‚¯ãƒ©ã‚¹ã”ã¨ã®è‰²
  const colorMap = { "ä¸¸":"#1e90ff", "å››è§’":"#00c853", "ä¸‰è§’":"#ff1744" };

  // é›†è¨ˆç”¨
  const counts = { "ä¸¸":0, "å››è§’":0, "ä¸‰è§’":0 };

  // å¯è¦–åŒ–ç”¨ç”»åƒ
  let vis = src.clone();

  // ç‰©ä½“ã”ã¨ã«åˆ†é¡
  // TMã¸æ¸¡ã™ä¸€æ™‚ã‚­ãƒ£ãƒ³ãƒã‚¹ï¼ˆåˆ‡ã‚Šå‡ºã—è¡¨ç¤ºç”¨ï¼‰
  const roiCanvas = document.createElement('canvas');
  const roiCtx = roiCanvas.getContext('2d');

  for (let i = 0; i < contours.size(); ++i) {
    const cnt = contours.get(i);
    const area = cv.contourArea(cnt);
    if (area < MIN_AREA) { cnt.delete(); continue; }

    const r = cv.boundingRect(cnt);

    const touchesEdge =
      r.x <= EDGE_MGN || r.y <= EDGE_MGN ||
      (r.x + r.width)  >= (W - EDGE_MGN) ||
      (r.y + r.height) >= (H - EDGE_MGN);

    const isHuge = area > MAX_FRAC * W * H;
    if (touchesEdge || isHuge) { cnt.delete(); continue; }

    // ROIï¼ˆä½™ç™½ã¤ãã§å®‰å…¨ã«åˆ‡ã‚Šå‡ºã—ï¼‰
    const x0 = Math.max(0, r.x - PAD);
    const y0 = Math.max(0, r.y - PAD);
    const x1 = Math.min(W, r.x + r.width + PAD);
    const y1 = Math.min(H, r.y + r.height + PAD);
    const rw = x1 - x0;
    const rh = y1 - y0;

    // ROIã‚’HTMLã‚­ãƒ£ãƒ³ãƒã‚¹ã«æãå‡ºã—ã¦TMã¸
    roiCanvas.width = rw;
    roiCanvas.height = rh;
    // vis ã§ã¯ãªãå…ƒã®ç”»åƒã‚’ä½¿ã£ã¦åˆ‡ã‚Šå‡ºã™
    // ï¼ˆcv.imshow ã‚’ä»‹ã•ãšã€è¡¨ç¤ºä¸­ã®Canvasã‹ã‚‰ç›´æ¥drawImageï¼‰
    // ã„ã£ãŸã‚“å¤§ããªCanvasã‹ã‚‰åˆ‡ã‚Šå‡ºã™ãŸã‚ã€æ—¢å­˜ã®å¤§æœ¬canvasã‚’ä½¿ã†
    // â†’ ã“ã“ã§ã¯ src(Mat) ã‹ã‚‰ç›´æ¥ã¯æã‘ãªã„ãŸã‚ã€è¡¨ç¤ºæ¸ˆã¿canvasã‹ã‚‰æŠœãï¼š
    roiCtx.drawImage(canvas, x0, y0, rw, rh, 0, 0, rw, rh);

    // TMã§åˆ†é¡
    const preds = await tmModel.predict(roiCanvas);
    preds.sort((a,b)=>b.probability - a.probability);
    const best = preds[0];

    // ã€Œãªã—ã€ä»¥å¤–ã§ã—ãã„å€¤ã‚’è¶…ãˆãŸã‚‰æ ï¼†ãƒ©ãƒ™ãƒ«
    if (best.className !== "ãªã—" && best.probability >= THRESH) {
      counts[best.className] = (counts[best.className] || 0) + 1;

      // æ è‰²
      const hex = colorMap[best.className] || "#ffd600";
      const col = new cv.Scalar(
        parseInt(hex.slice(1,3),16),
        parseInt(hex.slice(3,5),16),
        parseInt(hex.slice(5,7),16),
        255
      );

      // æ ã‚’æã
      cv.rectangle(
        vis,
        new cv.Point(r.x, r.y),
        new cv.Point(r.x + r.width, r.y + r.height),
        col, 2
      );

      // ãƒ©ãƒ™ãƒ«æç”»ï¼ˆCanvas 2D ã§ãƒ†ã‚­ã‚¹ãƒˆï¼‰
      // OpenCVã§æ–‡å­—ã‚’å…¥ã‚Œã‚‹ã‚ˆã‚ŠJSã®æ–¹ãŒç¶ºéº—ã«æã‘ã‚‹ãŸã‚ã€ã‚ã¨ã§ä¸Šã‹ã‚‰é‡ã­ã‚‹
      // â†’ å…ˆã«OpenCVã®ç”»åƒã‚’å‡ºã—ã¦ã‹ã‚‰ã€ãƒ†ã‚­ã‚¹ãƒˆã¯2Dã§æã
      // ä½ç½®ã ã‘è¦šãˆã¦ãŠã
      if (!vis._labels) vis._labels = [];
      vis._labels.push({
        x: r.x + 4, y: Math.max(16, r.y + 16),
        text: `${best.className} ${(best.probability*100).toFixed(0)}%`,
        hex
      });
    }

    cnt.delete();
  }

  // OpenCVç”»åƒã‚’è¡¨ç¤º
  cv.imshow(canvas, vis);

  // ãƒ©ãƒ™ãƒ«ã‚’Canvas 2Dã§é‡ã­æãï¼ˆã‚¢ãƒ³ãƒã‚¨ã‚¤ãƒªã‚¢ã‚¹æ–‡å­—ï¼‰
  const ctx2d = canvas.getContext('2d');
  if (vis._labels) {
    ctx2d.font = "16px sans-serif";
    vis._labels.forEach(l => {
      ctx2d.fillStyle = l.hex;
      ctx2d.fillText(l.text, l.x, l.y);
    });
  }

  // çµæœã®é›†è¨ˆã‚’è¡¨ç¤ºï¼ˆä¾‹ï¼šã€Œä¸¸2ãƒ»å››è§’1ãƒ»ä¸‰è§’0ã€ï¼‰
  const total = counts["ä¸¸"] + counts["å››è§’"] + counts["ä¸‰è§’"];
  const summary = `æ¤œå‡ºæ•°: ä¸¸ ${counts["ä¸¸"]} / å››è§’ ${counts["å››è§’"]} / ä¸‰è§’ ${counts["ä¸‰è§’"]}ï¼ˆåˆè¨ˆ ${total}ï¼‰`;
  // æ—¢å­˜ã®1æšå…¨ä½“ã®ãƒˆãƒƒãƒ—çµæœè¡¨ç¤ºã«åŠ ãˆã¦ã€ä¸‹è¡Œã§å€‹æ•°ã‚µãƒãƒªã‚’ä»˜ä¸
  resultEl.innerHTML += `<br>${summary}`;

  // å¾Œå§‹æœ«
  vis.delete();
  src.delete(); gray.delete(); contours.delete(); hierarchy.delete();
}


      };
      img.src = URL.createObjectURL(file);
    });
  </script>
</body>
</html>